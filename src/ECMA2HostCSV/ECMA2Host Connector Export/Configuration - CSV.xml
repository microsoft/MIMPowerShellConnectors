<?xml version="1.0"?>
<Configuration xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Connectors>
    <Connector>
      <ConnectorConfig>
        <Parameters>
          <Parameter>
            <Name>Distinguished Name Style</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>None</Value>
          </Parameter>
          <Parameter>
            <Name>Export Type</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>ObjectReplace</Value>
          </Parameter>
          <Parameter>
            <Name>Data Normalization</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>None</Value>
          </Parameter>
          <Parameter>
            <Name>Object Confirmation</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>Normal</Value>
          </Parameter>
          <Parameter>
            <Name>Use DN As Anchor (Only LDAP style DN)</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Concurrent Operations Of Several Connectors</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>1</Value>
          </Parameter>
          <Parameter>
            <Name>Partitions (Only LDAP style DN)</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Hierarchy (Only LDAP style DN)</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Import</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>1</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Delta Import</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Export</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>1</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Full Export</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>No Reference Values In First Export Pass</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Object Rename</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Delete-Add As Replace</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Password operations</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Export Password In First Pass</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Partition Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Hierarchy Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Begin Import Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Import Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>param(
  [System.Collections.ObjectModel.KeyedCollection[string, Microsoft.MetadirectoryServices.ConfigParameter]]

  [ValidateNotNull()]

  $ConfigParameters,

  [Microsoft.MetadirectoryServices.Schema]

  [ValidateNotNull()]

  $Schema,

  [Microsoft.MetadirectoryServices.OpenImportConnectionRunStep]

  $OpenImportConnectionRunStep,

  [Microsoft.MetadirectoryServices.ImportRunStep]

  $GetImportEntriesRunStep,

  [pscredential]

  $PSCredential

)

Set-PSDebug -Strict

$commonModule = (Join-Path -Path ([Microsoft.MetadirectoryServices.MAUtils]::MAFolder) -ChildPath $ConfigParameters['Common Module Script Name (with extension)'].Value)
Import-Module -Name $commonModule -Verbose:$false -ErrorAction Stop

$importResults = New-Object -TypeName 'Microsoft.MetadirectoryServices.GetImportEntriesResults'

$csEntries = New-Object -TypeName 'System.Collections.Generic.List[Microsoft.MetadirectoryServices.CSEntryChange]'

$columnsToImport = $Schema.Types[0].Attributes

Write-Verbose "Loaded $($columnsToImport.Count) attributes to import"

$importCsvParameters = @{

  Path = (Join-Path -Path (Get-xADSyncPSConnectorFolder -Folder ManagementAgent) -ChildPath (Get-xADSyncPSConnectorSetting -Name 'FileName' -Scope Global -ConfigurationParameters $ConfigParameters))

}

if ((Test-Path $importCsvParameters['Path'] -PathType Leaf) -eq $false)

{

  ##TODO: ECMA exception?

  throw "Could not find $($importCsvParameters['Path'])"

}

Write-Verbose "Import path: $($importCsvParameters['Path'])"

$delimiter = Get-xADSyncPSConnectorSetting -Name 'Delimiter' -Scope Global -ConfigurationParameters $ConfigParameters

if ($delimiter)

{

  $importCsvParameters.Add('Delimiter',$delimiter)

  Write-Verbose "Setting delimiter to $delimiter)"

}

$encoding = Get-xADSyncPSConnectorSetting -Name 'Encoding' -Scope Global -ConfigurationParameters $ConfigParameters

if ($encoding)

{

  ##TODO: Validation

  $importCsvParameters.Add('Encoding',$encoding)

  Write-Verbose "Setting encoding to $encoding)"

}

$recordsToImport = Import-Csv @importCsvParameters

Write-Verbose "Imported $($recordsToImport.Count) records"

foreach ($record in $recordsToImport)

{

  Write-Verbose 'Starting new record'

  ##TODO: Handle a missing anchor (what exception to throw?)

  $foundValidColumns = $false

  $entrySchema = $Schema.Types[0];
  $csEntry = New-xADSyncPSConnectorCSEntryChange -ObjectType $entrySchema.Name -ModificationType Add

  foreach ($column in $columnsToImport)

  {

    $columnName = $column.Name

    Write-Verbose "Processing column $columnName"

    if ($record.$columnName)

    {

      Write-Verbose 'Found column'

      $foundValidColumns = $true

      ##TODO: Support multivalue?

      $anchorAttrName = $entrySchema.AnchorAttributes[0].Name
      $value = [string]$record.$columnName

      Write-Verbose "$columnName with value equal $value"


      if ($columnName -eq $anchorAttrName)
      {


        $csEntry.AnchorAttributes.Add([Microsoft.MetadirectoryServices.AnchorAttribute]::Create($columnName,$value))
      }


      $csEntry | Add-xADSyncPSConnectorCSAttribute -ModificationType Add -Name $columnName -Value ([Collections.IList]($record.$columnName.Split(";")))

    }

  }

  if ($foundValidColumns)

  {

    Write-Verbose 'Publishing CSEntryChange'

    $csEntries.Add($csEntry)

  }

  Write-Verbose 'Record completed'

}

##TODO: Support paging

$importResults.CSEntries = $csEntries

$importResults.MoreToImport = $false

Write-Output $importResults</Value>
          </Parameter>
          <Parameter>
            <Name>End Import Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Begin Export Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Export Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>param(
  [System.Collections.ObjectModel.KeyedCollection[string, Microsoft.MetadirectoryServices.ConfigParameter]]

  $ConfigParameters,

  [Microsoft.MetadirectoryServices.Schema]

  $Schema,

  [Microsoft.MetadirectoryServices.OpenExportConnectionRunStep]

  $OpenExportConnectionRunStep,

  [System.Collections.Generic.IList[Microsoft.MetaDirectoryServices.CSEntryChange]]

  $CSEntries,

  [pscredential]

  $PSCredential

)

Set-PSDebug -Strict


$commonModule = (Join-Path -Path ([Microsoft.MetadirectoryServices.MAUtils]::MAFolder) -ChildPath $ConfigParameters['Common Module Script Name (with extension)'].Value)
Import-Module -Name $commonModule -Verbose:$false -ErrorAction Stop

function CreateCustomPSObject

{

  param

  (

    $PropertyNames = @()

  )

  $template = New-Object -TypeName System.Object

  foreach ($property in $PropertyNames)

  {

    $template | Add-Member -MemberType NoteProperty -Name $property -Value $null

  }

  return $template
}


function DeleteFromCsv
{
  param($CsvParameters,[string]$ColumnName,[string]$ColumnValue)

  try
  {
    Write-Verbose "Delete from CSV. File: $($CsvParameters.Path)"

    $csv = Import-Csv -Path $CsvParameters.Path -Delimiter $CsvParameters.Delimiter | Where-Object $ColumnName -NE $ColumnValue

    $csv | Export-Csv -Path $CsvParameters.Path -Delimiter $CsvParameters.Delimiter -NoTypeInformation
  }
  catch
  {
    Write-Error $_.ErrorDetails.Message
  }
}

$exportCsvParameters = @{

  Path = (Join-Path -Path (Get-xADSyncPSConnectorFolder -Folder ManagementAgent) -ChildPath (Get-xADSyncPSConnectorSetting -Name 'FileName' -Scope Global -ConfigurationParameters $ConfigParameters))

}



$csentryChangeResults = New-Object "System.Collections.Generic.List[Microsoft.MetadirectoryServices.CSEntryChangeResult]"

if ((Test-Path ([IO.Path]::GetDirectoryName($exportCsvParameters['Path'])) -PathType Container) -eq $false)

{

  ##TODO: ECMA exception?

  throw "Could not find $($exportCsvParameters['Path'])"

}

Write-Verbose "Export path: $($exportCsvParameters['Path'])"

$delimiter = Get-xADSyncPSConnectorSetting -Name 'Delimiter' -Scope Global -ConfigurationParameters $ConfigParameters

if ($delimiter)

{

  $exportCsvParameters.Add('Delimiter',$delimiter)

  Write-Verbose "Setting delimiter to $delimiter)"

}

$encoding = Get-xADSyncPSConnectorSetting -Name 'Encoding' -Scope Global -ConfigurationParameters $ConfigParameters

if ($encoding)

{

  ##TODO: Validation

  $exportCsvParameters.Add('Encoding',$encoding)

  Write-Verbose "Setting encoding to $encoding)"

}

$columnsToExport = @()

foreach ($attribute in $Schema.Types[0].Attributes)

{

  $columnsToExport += $attribute.Name

  Write-Verbose "Added attribute $($attribute.Name) to export list"

}



$csvSource = @()

Write-Verbose "Processing object $($entry.Identifier)"


foreach ($entry in $CSEntries)

{

  Write-Verbose "Processing object $($entry.Identifier). ObjectModificationType $($entry.ObjectModificationType)"

  [bool]$objectHasAttributes = $false

  $baseObject = CreateCustomPSObject -PropertyNames $columnsToExport

  if ($entry.ObjectModificationType -eq 'Replace')
  {
    $anchorAttributeName = $entry.AnchorAttributes[0].Name;
    $anchorAttributeValue = $entry.AnchorAttributes[0].Value.ToString();
    Write-Verbose "Remove the object with attribute '$($anchorAttributeName)' equals '$($anchorAttributeValue)' before replacing it with new object"
    DeleteFromCsv -CsvParameters $exportCsvParameters -ColumnName $anchorAttributeName -ColumnValue $anchorAttributeValue
  }


  if ($entry.ObjectModificationType -ne 'Delete')

  {

    foreach ($attribute in $columnsToExport)

    {

      if (($entry.AttributeChanges.Contains($attribute)) -eq $false -and ($entry.AnchorAttributes.Contains($attribute) -eq $false))

      {

        continue

      }


      if ($entry.AnchorAttributes[$attribute].Value)

      {

        $baseObject.$attribute = $entry.AnchorAttributes[$attribute].Value

        $objectHasAttributes = $true

      }

      elseif ($entry.AttributeChanges[$attribute].ValueChanges[0].Value)

      {

        $baseObject.$attribute = ($entry.AttributeChanges[$attribute].ValueChanges | Select-Object -Expand Value) -join ";"

        $objectHasAttributes = $true

      }

    }

    if ($objectHasAttributes)

    {

      foreach ($property in $baseObject.PSObject.Properties)
      { 
          if ($property.Value -eq $null)
          {
              $baseObject.($property.Name) = ""
          }
      }
      
      $csvSource += $baseObject

    }

  }
  else
  {
    $anchorAttributeName = $entry.AnchorAttributes[0].Name;
    $anchorAttributeValue = $entry.AnchorAttributes[0].Value.ToString();
    Write-Verbose "Delete the object with attribute '$($anchorAttributeName)' equals '$($anchorAttributeValue)'"
    DeleteFromCsv -CsvParameters $exportCsvParameters -ColumnName $anchorAttributeName -ColumnValue $anchorAttributeValue
  }

  $csentryChangeResult = [Microsoft.MetadirectoryServices.CSEntryChangeResult]::Create($entry.Identifier,$null,"Success")
  $csentryChangeResults.Add($csentryChangeResult)

  Write-Verbose "Completed processing object $($entry.Identifier)"

}

$csvSource | Export-Csv @exportCsvParameters -NoTypeInformation -Append -Force

$closedType = [type]"Microsoft.MetadirectoryServices.PutExportEntriesResults"

return [Activator]::CreateInstance($closedType,$csentryChangeResults)</Value>
          </Parameter>
          <Parameter>
            <Name>End Export Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Begin Password Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Password Extension Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>End Password Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>PowerShell script execution timeout in minutes (0 â€“ disabled)</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>FileName_Global</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>InputFile.txt</Value>
          </Parameter>
          <Parameter>
            <Name>Delimiter_Global</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>;</Value>
          </Parameter>
          <Parameter>
            <Name>Encoding_Global</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>FileName_RunStep</Name>
            <Type>String</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>InputFile.txt</Value>
          </Parameter>
          <Parameter>
            <Name>Delimiter_RunStep</Name>
            <Type>String</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>;</Value>
          </Parameter>
          <Parameter>
            <Name>Encoding_RunStep</Name>
            <Type>String</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>PageSizeFullImport</Name>
            <Type>Text</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>5000</Value>
          </Parameter>
          <Parameter>
            <Name>Server</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Domain</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>User</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Password</Name>
            <Type>EncryptedString</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>true</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Impersonate Connector Account</Name>
            <Type>CheckBox</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Load User Profile When Impersonating</Name>
            <Type>CheckBox</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Logon Type When Impersonating</Name>
            <Type>DropDown</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>None</Value>
          </Parameter>
          <Parameter>
            <Name>Signed Scripts Only</Name>
            <Type>CheckBox</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Common Module Script Name (with extension)</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>xADSyncPSConnectorModule.psm1</Value>
          </Parameter>
          <Parameter>
            <Name>Common Module Script</Name>
            <Type>Text</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>
Set-PSDebug -Strict

function Enter-Script
{
  &lt;#
    .Synopsis
    Writes the Versbose message saying specified script execution started.
    .Description
    Writes the Versbose message saying specified script execution started.
    Also clear the $Error variable.
  #&gt;
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string]
    $ScriptType,
    [Parameter(Mandatory = $false)]
    [ValidateNotNull()]
    [System.Collections.ArrayList]
    $ErrorObject
  )

  process
  {
    Write-Verbose "$Global:ConnectorName - $ScriptType Script: Execution Started..."
    if ($ErrorObject)
    {
      $ErrorObject.Clear()
    }
  }
}

function Exit-Script
{
  &lt;#
    .Synopsis
    Checks $Error variable for any Errors. Writes the Versbose message saying specified script execution sucessfully completed.
    .Description
    Checks $Error variable for any Errors. Writes the Versbose message saying specified script execution sucessfully completed.
    Throws an exception if $Error is present
  #&gt;
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string]
    $ScriptType,
    [Parameter(Mandatory = $false)]
    [ValidateNotNull()]
    [System.Collections.ArrayList]
    $ErrorObject,
    [Parameter(Mandatory = $false)]
    [switch]
    $SuppressErrorCheck,
    [Parameter(Mandatory = $false)]
    [type]
    $ExceptionRaisedOnErrorCheck
  )

  process
  {
    if (!$SuppressErrorCheck -and $ErrorObject -and $ErrorObject.Count -ne 0)
    {
      # Take the first one otherwise you get "An error occurred while enumerating through a collection: Collection was modified; enumeration operation may not execute.."
      # Seems like a bug in Remote PSH
      $errorMessage = $ErrorObject[0] # | Out-String -ErrorAction SilentlyContinue

      if ($ExceptionRaisedOnErrorCheck -eq $null)
      {
        $ExceptionRaisedOnErrorCheck = [Microsoft.MetadirectoryServices.ExtensibleExtensionException]
      }

      $ErrorObject.Clear()

      throw $errorMessage -as $ExceptionRaisedOnErrorCheck
    }

    Write-Verbose "$Global:ConnectorName - $ScriptType Script: Execution Completed."
  }
}

function Get-ExtensionsDirectory
{
  &lt;#
    .Synopsis
    Gets the path of the "Extensions" folder.
    .Description
    Gets the path of the "Extensions" folder.
  #&gt;
  [CmdletBinding()]
  [OutputType([string])]
  param(
  )

  process
  {
    $scriptDir = "C:\\Program Files\\Microsoft ECMA2Host\\Service\\ECMA"

    return $scriptDir
  }
}

function ConvertFrom-SchemaXml
{
    &lt;#
    .Synopsis
    Converts a connector schema defined in a xml file into a "Microsoft.MetadirectoryServices.Schema" object.
    .Description
    Converts a connector schema defined in a xml file into a "Microsoft.MetadirectoryServices.Schema" object.
    .Example
    ConvertFrom-SchemaXml -SchemaXml "Schema.xml"
    #&gt;  

  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.Schema])]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateScript({ Test-Path $_ -PathType "Leaf" })]
    [string]
    $SchemaXml
  )

  process
  {
    $x = [xml](Get-Content $SchemaXml)

    $schema = [Microsoft.MetadirectoryServices.Schema]::Create()

    foreach ($t in $x.Schema.Types.SchemaType)
    {
      $lockAnchorDefinition = $true

      if ($t.LockAnchorDefinition -eq "0")
      {
        $lockAnchorDefinition = $false
      }

      $schemaType = [Microsoft.MetadirectoryServices.SchemaType]::Create($t.Name,$lockAnchorDefinition)

      if ($t.GetElementsByTagName("PossibleDNComponentsForProvisioning").Count -gt 0)
      {
        foreach ($c in $t.PossibleDNComponentsForProvisioning)
        {
          $schemaType.PossibleDNComponentsForProvisioning.Add($c)
        }
      }

      foreach ($a in $t.Attributes.SchemaAttribute)
      {
        if ($a.IsAnchor -eq 1)
        {
          $schemaType.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateAnchorAttribute($a.Name,$a.DataType,$a.AllowedAttributeOperation))
        }
        elseif ($a.IsMultiValued -eq 1)
        {
          $schemaType.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateMultiValuedAttribute($a.Name,$a.DataType,$a.AllowedAttributeOperation))
        }
        else
        {
          $schemaType.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($a.Name,$a.DataType,$a.AllowedAttributeOperation))
        }
      }

      $schema.Types.Add($schemaType)
    }

    return $schema
  }
}


function Get-xADSyncPSConnectorSetting
{
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNull()]
    [Alias('InputObject')]
    [System.Collections.ObjectModel.KeyedCollection[string, Microsoft.MetadirectoryServices.ConfigParameter]]
    $ConfigurationParameters,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $Name,
    [Parameter(Mandatory = $true)]
    [ValidateSet('Global','Partition','RunStep')]
    [string]
    $Scope,
    $DefaultValue
  )
  process
  {
    try
    {
      $scopedName = '{0}_{1}' -f $Name,$Scope

      if ($ConfigurationParameters[$scopedName].Value)
      {
        return $ConfigurationParameters[$scopedName].Value
      }
      elseif ($PSBoundParameters.ContainsKey('DefaultValue'))
      {
        return $DefaultValue
      }
      else
      {
        return $null
      }
    }
    catch [System.Collections.Generic.KeyNotFoundException]
    {
      # if they gave us a default, go ahead and return it
      if ($PSBoundParameters.ContainsKey('DefaultValue'))
      {
        return $DefaultValue
      }
      else
      {
        throw
      }
    }
  }
}

function Get-xADSyncPSConnectorFolder
{
  [CmdletBinding()]
  [OutputType([string])]
  param(
    [Parameter(Mandatory = $true,Position = 0)]
    [ValidateSet('ManagementAgent','Extensions')]
    [string]
    $Folder
  )

  switch ($Folder)
  {
    'ManagementAgent'
    {
      return [Microsoft.MetadirectoryServices.MAUtils]::MAFolder
    }
    'Extensions'
    {
      return [Microsoft.MetadirectoryServices.Utils]::ExtensionsDirectory
    }
    default
    {
      throw "Folder '$Folder' is not supported"
    }
  }
}

#region Schema Helpers
function New-xADSyncPSConnectorSchema
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.Schema])]
  param()

  return [Microsoft.MetadirectoryServices.Schema]::Create()
}

function New-xADSyncPSConnectorSchemaType
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.SchemaType])]
  param(
    [ValidateNotNullOrEmpty()]
    [string]
    $Name,
    [switch]
    $LockAnchorAttributeDefinition
  )

  return [Microsoft.MetadirectoryServices.SchemaType]::Create($Name,$LockAnchorAttributeDefinition.ToBool())
}

function Add-xADSyncPSConnectorSchemaAttribute
{
  [CmdletBinding(DefaultParameterSetName = 'Singlevalued')]
  param(
    [Parameter(Mandatory = $true,ValueFromPipeline = $true)]
    [Microsoft.MetadirectoryServices.SchemaType]
    [ValidateNotNull()]
    $InputObject,
    [ValidateNotNullOrEmpty()]
    [string]
    [Parameter(Mandatory = $true,ParameterSetName = 'Anchor')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Multivalued')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Singlevalued')]
    $Name,
    [Parameter(ParameterSetName = 'Anchor')]
    [switch]
    $Anchor,
    [Parameter(ParameterSetName = 'Multivalued')]
    [switch]
    $Multivalued,
    [Parameter(Mandatory = $true,ParameterSetName = 'Anchor')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Multivalued')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Singlevalued')]
    [ValidateSet('Binary','Boolean','Integer','Reference','String')]
    [string]
    $DataType,
    [Parameter(Mandatory = $true,ParameterSetName = 'Anchor')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Multivalued')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Singlevalued')]
    [ValidateSet('ImportOnly','ExportOnly','ImportExport')]
    [string]
    $SupportedOperation
  )

  process
  {
    switch ($PSCmdlet.ParameterSetName)
    {
      'Singlevalued'
      {
        $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($Name,$DataType,$SupportedOperation))
      }
      'Multivalued'
      {
        if ($Multivalued.ToBool() -eq $true)
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateMultiValuedAttribute($Name,$DataType,$SupportedOperation))
        }
        else
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($Name,$DataType,$SupportedOperation))
        }
      }
      'Anchor'
      {
        if ($Anchor.ToBool() -eq $true)
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateAnchorAttribute($Name,$DataType,$SupportedOperation))
        }
        else
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($Name,$DataType,$SupportedOperation))
        }
      }
      default
      {
        throw "Parameter set '$($PSCmdlet.ParameterSetName)' is not supported"
      }
    }
  }
}
#endregion

#region Partition Helpers
function New-FIMPSConnectorPartition
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetaDirectoryServices.Partition])]
  param(
    [Parameter(Mandatory = $true)]
    [guid]
    $Identifier,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DistinguishedName,
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DisplayName
  )

  if ($PSBoundParameters.ContainsKey('DisplayName'))
  {
    return [Microsoft.MetadirectoryServices.Partition]::Create($Identifier,$DistinguishedName,$DisplayName)
  }
  else
  {
    return [Microsoft.MetadirectoryServices.Partition]::Create($Identifier,$DistinguishedName)
  }
}
#endregion
function New-xADSyncPSConnectorHierarchyNode
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.HierarchyNode])]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DistinguishedName,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DisplayName
  )

  return [Microsoft.MetadirectoryServices.HierarchyNode]::Create($DistinguishedName,$DisplayName)
}
#region Hierarchy Helpers

#endregion

#region Import Helpers
function New-xADSyncPSConnectorCSEntryChange
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.CSEntryChange])]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $ObjectType,
    [Parameter(Mandatory = $true)]
    [ValidateSet('Add','Delete','Update','Replace','None')]
    [string]
    $ModificationType,
    [ValidateNotNullOrEmpty()]
    [Alias('DistinguishedName')]
    [string]
    $DN,
    [ValidateNotNullOrEmpty()]
    [Alias('RelativeDistinguishedName')]
    [string]
    $RDN
  )

  $csEntry = [Microsoft.MetadirectoryServices.CSEntryChange]::Create()
  $csEntry.ObjectModificationType = $ModificationType
  $csEntry.ObjectType = $ObjectType

  if ($PSBoundParameters.ContainsKey('DN'))
  {
    $csEntry.DN = $DN
  }

  if ($PSBoundParameters.ContainsKey('RDN'))
  {
    $csEntry.RDN = $RDN
  }

  Write-Output $csEntry
}

function Add-xADSyncPSConnectorCSAttribute
{
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true,ValueFromPipeline = $true)]
    [Microsoft.MetadirectoryServices.CSEntryChange]
    [ValidateNotNull()]
    $InputObject,
    [Parameter(Mandatory = $true)]
    [ValidateSet('Add','Update','Delete','Replace','Rename')]
    [string]
    $ModificationType,
    [ValidateNotNullOrEmpty()]
    [string]
    $Name,
    $Value
  )

  process
  {
    if ($ModificationType -ne 'Rename' -and $Name -eq $null)
    {
      throw 'Name parameter is required'
    }

    if ($ModificationType -ne 'Delete' -and $Value -eq $null)
    {
      throw 'Value parameter is required'
    }

    switch ($ModificationType)
    {
      'Add'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeAdd($Name,$Value))
      }
      'Update'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeUpdate($Name,$Value))
      }
      'Delete'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeDelete($Name))
      }
      'Replace'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeReplace($Name,$Value))
      }
      'Rename'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateNewDN($Value))
      }
      default
      {
        throw "Modification type $ModificationType is not supported"
      }
    }
  }
}
#endregion

function New-GenericObject
{
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $TypeName,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string[]]
    $TypeParameters,
    [Parameter(Mandatory = $false)]
    [object[]]
    $ConstructorParameters
  )

  $genericTypeName = $typeName + '
              `r`n' + $typeParameters.Count
  $genericType = [type]$genericTypeName

  if (!$genericType)
  {
    throw "Could not find generic type $genericTypeName"
  }

  ## Bind the type arguments to it
  $typedParameters = [Type[]]$typeParameters
  $closedType = $genericType.MakeGenericType($typedParameters)

  if (!$closedType)
  {
    throw "Could not make closed type $genericType"
  }

  ## Create the closed version of the generic type. Don't forget comma prefix
  ,[Activator]::CreateInstance($closedType,$constructorParameters)
}

Export-ModuleMember -Function * -Verbose:$false -Debug:$false</Value>
          </Parameter>
          <Parameter>
            <Name>Validation Script</Name>
            <Type>Text</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Schema Script</Name>
            <Type>Text</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>[CmdletBinding()]
param(
  [Parameter(Mandatory = $true)]
  [System.Collections.ObjectModel.KeyedCollection[string,Microsoft.MetadirectoryServices.ConfigParameter]]
  $ConfigParameters,
  [Parameter(Mandatory = $false)]
  [Alias('PSCredential')] # To fix mess-up of the parameter name in the RTM version of the PowerShell connector.
  [System.Management.Automation.PSCredential]
  $Credential,
  [Parameter(Mandatory = $false)]
  [ValidateScript({ Test-Path $_ -PathType "Container" })]
  [string]
  $ScriptDir = (Join-Path -Path $env:windir -ChildPath "TEMP") # Optional parameter for manipulation by the TestHarness script.
)

Set-StrictMode -Version "2.0"

$Global:DebugPreference = "Continue"
$Global:VerbosePreference = "Continue"

$commonModule = (Join-Path -Path ([System.Environment]::GetEnvironmentVariable('Temp', 'Machine')) -ChildPath $ConfigParameters["Common Module Script Name (with extension)"].Value)

if (!(Get-Module -Name (Get-Item $commonModule).BaseName)) { Import-Module -Name $commonModule }

Enter-Script -ScriptType "Schema" -ErrorObject $Error

function Get-ConnectorSchema
{
&lt;#
    .Synopsis
    Gets the connector space schema.
    .Description
    Gets the connector space schema defined in the "Schema.xml" file.
#&gt;

  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.Schema])]
  param(
  )

  $extensionsDir = Get-ExtensionsDirectory
  $schemaXml = Join-Path -Path $extensionsDir -ChildPath "Schema.xml"

  $schema = ConvertFrom-SchemaXml -SchemaXml $schemaXml

  return $schema
}

Get-ConnectorSchema

Exit-Script -ScriptType "Schema" -ErrorObject $Error</Value>
          </Parameter>
          <Parameter>
            <Name>Additional Config Parameter Names</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>FileName,Delimiter,Encoding</Value>
          </Parameter>
          <Parameter>
            <Name>Additional Encrypted Config Parameter Names</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
        </Parameters>
        <RunConfigurations>
          <RunConfiguration>
            <Id>9fd4ccfc-55b6-4e3a-a9ac-ef2f451018e7</Id>
            <Name>Export</Name>
            <VersionNumber>0</VersionNumber>
            <CreationTime>2023-04-27T21:33:19.2865423-07:00</CreationTime>
            <LastModificationTime>2023-04-27T21:33:19.2865423-07:00</LastModificationTime>
            <RunSteps>
              <RunStep>
                <Name>Export</Name>
                <Type>None</Type>
                <Partition>default</Partition>
                <BatchSize>0</BatchSize>
                <Timeout>0</Timeout>
                <Parameters>
                  <Parameter>
                    <Name>FileName_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>InputFile.txt</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Delimiter_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>;</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Encoding_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value />
                  </Parameter>
                  <Parameter>
                    <Name>PageSizeExport</Name>
                    <Type>Text</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>5000</Value>
                  </Parameter>
                </Parameters>
              </RunStep>
            </RunSteps>
          </RunConfiguration>
          <RunConfiguration>
            <Id>4587911e-9173-4324-98fd-a8e6207bae33</Id>
            <Name>FullImport</Name>
            <VersionNumber>0</VersionNumber>
            <CreationTime>2023-04-27T21:33:46.7386769-07:00</CreationTime>
            <LastModificationTime>2023-04-27T21:33:46.7386769-07:00</LastModificationTime>
            <RunSteps>
              <RunStep>
                <Name>Import</Name>
                <Type>None</Type>
                <Partition>default</Partition>
                <BatchSize>0</BatchSize>
                <Timeout>0</Timeout>
                <Parameters>
                  <Parameter>
                    <Name>FileName_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>InputFile.txt</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Delimiter_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>;</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Encoding_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value />
                  </Parameter>
                  <Parameter>
                    <Name>PageSizeFullImport</Name>
                    <Type>Text</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>5000</Value>
                  </Parameter>
                </Parameters>
              </RunStep>
            </RunSteps>
          </RunConfiguration>
        </RunConfigurations>
        <IsExportSupported>true</IsExportSupported>
        <IsFullImportSupported>true</IsFullImportSupported>
        <IsDeltaImportSupported>false</IsDeltaImportSupported>
        <IsExportOnly>false</IsExportOnly>
      </ConnectorConfig>
      <Schema>
        <EntriesSchema>
          <EntrySchema>
            <ExternalName>User</ExternalName>
            <ObjectType>Person</ObjectType>
            <SchemaAttributes>
              <AttributeSchema>
                <Name>AzureObjectID</Name>
                <IsAnchor>true</IsAnchor>
                <IsDN>true</IsDN>
                <IsQueryAttribute>true</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>DisplayName</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>Email</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>EmployeeId</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>IsActive</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>Boolean</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>Title</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>UserName</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
            </SchemaAttributes>
            <IsDNAutogenerated>false</IsDNAutogenerated>
            <DeprovisioningModel>
              <HardDeleteStatusAttribute />
              <SoftDeleteStatusAttribute />
              <HardDelete>TreatAsHard</HardDelete>
              <SoftDelete>None</SoftDelete>
            </DeprovisioningModel>
          </EntrySchema>
        </EntriesSchema>
        <Partitions>
          <Partition>
            <Id>ba05a46c-9390-4b85-9019-a1811be08949</Id>
            <Name>default</Name>
            <DN>default</DN>
          </Partition>
        </Partitions>
        <ExportPasswordInFirstPass>False</ExportPasswordInFirstPass>
        <SupportPassword>False</SupportPassword>
      </Schema>
      <ECMAConfig>
        <ECMAFolderPath />
        <LibraryName>Microsoft.IAM.Connector.PowerShell</LibraryName>
        <AutosyncTimer>120</AutosyncTimer>
        <SecretToken></SecretToken>
        <ProfileName>CSV</ProfileName>
        <CreationDateTime>Thursday, April 27, 2023 9:09:03 PM</CreationDateTime>
        <ModificationDateTime>Thursday, April 27, 2023 9:22:22 PM</ModificationDateTime>
        <Validated>true</Validated>
      </ECMAConfig>
    </Connector>
  </Connectors>
  <Setting>
    <Port>8585</Port>
    <Certificate>B1059D9236D99040B597C34DC736733870CBF652</Certificate>
  </Setting>
</Configuration>